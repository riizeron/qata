Проанализировав результаты написанных тестов, можно сделать следущие выводы касательно тестируемого кода.

1) AccountManager не содержит в себе обработки поведения при ответе от сервера типа UNDEFINED_ERROR, поэтому он отправляет ответ с кодом INCORRECT_RESPONSE, являющийся дефолтным при ненахождении совпадений. Это противоричит спецификации. 

Для корректной работы программы, необходимо определить, что при ответе от сервера типа UNDEFINED_ERROR, AccountManager будет отправлять ответ с кодом UNDEFINED_ERROR.

Данная бага(фича) была замечена в ходе выполнение тестов на проверку корректности интеграции сервера и менеджера при ответе сервера типа UNDEFINED_ERROR. Поведение при данном ответе некорректно во всех методах класса AccountManagers.

ИСПРАВЛЕНИЕ:

Необходимо добавить в switch-case каждого метода строки:

'''
case ServerResponse.UNDEFINED_ERROR:
        return AccountManagerResponse.UNDEFINED_ERROR_RESPONSE;
'''

2) AccountManager не записывает пользователя в 'activeAccounts' при успешной авторизации. При всем при этом, в момент вызова каждого метода менеджера проверяется присутствие пользователя в данной 'базе', а его там попросту не оказыватеся, вследствие чего менеждер отправляет ответ NOT_LOGGED. Из-за этого при даже при успешной, согласно спецификации, авторизации оказывается невозможным выполнить никакое действие, ведь мы получаем NOT_LOGGED от менеджера.

Для корректной работы программы необходимо добавлять пользователя в activeAccounts, при его успешной авторизации. Следует также, возможно, добавить условие о том, что 'база' активных пользователей пополняется на одну единицу при их успешной авторизации.

Дынная бага(фича) была замечена в ходе тестирования работоспособности методов в целом. В связи с этим проверить методы при успешно проведенной авторизации и различных входных данных оказалось невозможно, ведь тест сразу падал из-за проверки менеджера на присутствие пользователя в 'базе'. 

Поскольку за пополнение базы отвечает менеджер, эту ошибку было бы легко отловаить тестом, проверяющим корректное добавление пользователя в 'базу' при успешной пройденной авторизации. Однако, данного условия не было в спецификации. И, возможно, следует его туда добавить.

Также хочу заметить, что вследствие этой баги(фичи), проверки поведения методов менеджера при неавторизованном пользователе теряют свой смысл, поскольку будут успешными всегда.

ИСПРАВЛЕНИЕ:

Изменить следущую секцию в методе callLogin менеджера c этого:

```
if (answ instanceof Long)
    return new AccountManagerResponse(AccountManagerResponse.SUCCEED, answ);
```
на это:

```
if (answ instanceof Long) {
    activeAccounts.put(login, (Long)answ);
    return new AccountManagerResponse(AccountManagerResponse.SUCCEED, answ);
```

3) В методе callLogout класса менеджера не происходит проверка на корректность сессии, в связи с чем сервер, при вызове метода logout с передачей в качестве параметра некорректного номера сессии, возвращает null, поскольку имеет мок только на коррекный номер.

Данная бага(фича) была замечена в тестировании метода callLogout классе менеджера при передаче в него некорректного номера сессии. Тест падал, из-за NullReferenceExxception, потому что сервер на некоррекную сессию отвечал null ответом.

ИСПРАВЛЕНИЕ:

Добавить в метод callLogout менеджера проверку на идентичность сессии извлеченного пользователя сессии, переданной в качестве параметра.

```
if (rem != session) {
    return AccountManagerResponse.INCORRECT_SESSION_RESPONSE;
}
```

4) Также хочу отметить то, что в методе callLogout, при неуспешном его завершении, пользователь все равно будет удален. Это происходит, потому что для получения пользователя по логину в хеш мапе используется метод удаления(remove) вместо метода get. Причем обратно, при неуспешном 'callLogout', он не добавляется.

Данная бага(фича) была замечена невооруженным глазом(без тестов), поскольку подобного сценария, позволяющего проверить эту функцию по таким углом не было описано в задании, а всеми остальными тестами, написанными в соответствии с приведенной спецификацией программы, она попросту не отлавливалась. Тем не менее, инцидент имеет место быть и его надо чинить(фиксить).

ИСПРАВЛЕНИЕ

Заменить метод remove в начале callLogout на метод get, а remove использовать только при положительном ответе от сервера (case ServerResponse.SUCCESS). То есть нужно в саом начале callLogout поменять это
```
Long rem = activeAccounts.remove(user);
```
на это:
```
Long rem = activeAccounts.get(user);
```
А в swith-case это:
```
case ServerResponse.SUCCESS:
    return AccountManagerResponse.SUCCEED_RESPONSE;
```
на это:
```
case ServerResponse.SUCCESS:
    activeAccounts.remove(user);
    return AccountManagerResponse.SUCCEED_RESPONSE;
```

Все!


По замечаниям(недочетам) касательно моей работы просьба отписаться мне по одному из следующих каналов связи.

Почта: vodavydov@edu.hse.ru

Телеграм: @blackout11


Буду очень рад обратной связи!

Спасибо за проверку)
